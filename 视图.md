

# lateral 

explote() 缺点 只能一个UDTF

组合 UDTF 函数explote 

hive Lateral View
Lateral View用于和UDTF函数（explode、split）结合来使用。
首先通过UDTF函数拆分成多行，再将多行结果组合成一个支持别名的虚拟表。
主要解决在select使用UDTF做查询过程中，查询只能包含单个UDTF，不能包含其他字段、以及多个UDTF的问题

语法：
LATERAL VIEW udtf(expression) tableAlias AS columnAlias (',' columnAlias)



## 示例

统计人员表中共有多少种爱好、多少个城市?

select count(distinct(myCol1)), count(distinct(myCol2)) from psn2 
LATERAL VIEW explode(likes) myTable1 AS myCol1 
LATERAL VIEW explode(address) myTable2 AS myCol2, myCol3;

 # 视图
     
     虚拟表 
     
     只能查询
     
     相当于一个过程只有在查看时才会执行
     
     show tables 
     
     迭代视图 
     
     View语法
     创建视图：
     CREATE VIEW [IF NOT EXISTS] [db_name.]view_name 
       [(column_name [COMMENT column_comment], ...) ]
       [COMMENT view_comment]
       [TBLPROPERTIES (property_name = property_value, ...)]
       AS SELECT ... ;
     查询视图：
     select colums from view;
     删除视图：
     DROP VIEW [IF EXISTS] [db_name.]view_name;
     
     
     
# 索引

生成新的表来存储

  用的不多 有缺陷 
    
创建

    语法
    
    as 处理器
    in table 索引表 （会有默认）
    创建索引：
    create index t1_index on table psn2(name) 
    as 'org.apache.hadoop.hive.ql.index.compact.CompactIndexHandler' with deferred rebuild 
    in table t1_index_table;
    as：指定索引器；
    in table：指定索引表，若不指定默认生成在default__psn2_t1_index__表中
    
    
        
内容
    
     列值 文件 偏移量

重建索引 重建才有数据

     每一次新增数据 都得 重建

建了索引反而慢

先查索引表 再查数据 步骤多  ，不是索引组织表     
    
删除索引表 

    drop on    
    
# orderby

mr 会到 一个 mr中 进行排序     